<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>2レーン音ゲー（秒単位同期・スマホ対応）</title>
<style>
body { margin:0; background:#111; color:white; font-family:sans-serif; overflow:hidden;}
canvas { display:block; margin:auto; background:black; touch-action:none; }
#ui { position:absolute; top:0; left:0; width:100%; height:100%; display:flex;
      justify-content:center; align-items:center; flex-direction:column; }
button { font-size:30px; padding:10px 30px; margin:10px; cursor:pointer; }
</style>
</head>
<body>
<canvas id="gameCanvas" width="400" height="600"></canvas>
<div id="ui">Loading...</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

const laneWidth = canvas.width / 2;
const hitLineY = 550;
const speedFactor = 300; // px/sec
const hitRangePerfectSec = 0.15;
const hitRangeGoodSec = 0.25;
const hitDisplayTime = 500;

let chart=[], notes=[], startTime=null;
let score=0, combo=0, gameState="start", currentHitText=null, currentCountdown=null;
let hitCounts={PERFECT:0,GOOD:0,MISS:0};

const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let bgmBuffer=null, bgmSource=null;

// JSON読み込み
fetch("chart.json")
.then(res=>res.json())
.then(data=>{
    chart = parseChartTiming(data);
    notes = chart.map(n=>({...n, hit:false}));
    if(data.bgm){
        fetch(data.bgm)
        .then(r=>r.arrayBuffer())
        .then(buf=>audioCtx.decodeAudioData(buf))
        .then(decoded=>{ bgmBuffer=decoded; showStartScreen(); })
        .catch(err=>{console.error("BGM読み込み失敗",err); showStartScreen(); });
    } else showStartScreen();
})
.catch(err=>{console.error("譜面読み込み失敗",err); ui.innerHTML="Error";});

function parseChartTiming(jsonChart){
    const bpm=jsonChart.bpm;
    const beatsPerMeasure=jsonChart.timeSignature[0];
    const secPerBeat=60/bpm;
    return jsonChart.notes.map(n=>({
        startTime: ((n.measure-1)*beatsPerMeasure + (n.beat-1))*secPerBeat,
        lane: n.lane
    }));
}

function showStartScreen(){
    gameState="start"; ui.innerHTML="";
    notes = chart.map(n=>({...n, hit:false}));
    const btn = document.createElement('button');
    btn.innerText="Start";
    btn.onclick=()=>startCountdown();
    ui.appendChild(btn);
}

function startCountdown(){
    gameState="countdown"; ui.innerHTML="";
    currentCountdown=3;
    const interval=setInterval(()=>{
        currentCountdown--;
        if(currentCountdown<=0){
            clearInterval(interval);
            currentCountdown=null;
            startBGMAndGame();
        }
    },1000);
}

function startBGMAndGame(){
    if(bgmBuffer){
        bgmSource=audioCtx.createBufferSource();
        bgmSource.buffer=bgmBuffer;
        bgmSource.connect(audioCtx.destination);
        startTime = audioCtx.currentTime + 0.05; // BGM開始に同期
        bgmSource.start(startTime);
        bgmSource.onended=()=>{ showResultScreen(); };
        startGame();
    } else {
        startTime = audioCtx.currentTime;
        startGame();
    }
}

function startGame(){
    gameState="playing";
    score=0; combo=0; currentHitText=null;
    hitCounts={PERFECT:0,GOOD:0,MISS:0};
}

function showResultScreen(){
    if(bgmSource) bgmSource.stop();
    gameState="result"; ui.innerHTML="";
    const div=document.createElement('div');
    div.innerHTML=`
        <div>Score: ${score}</div>
        <div>Combo: ${combo}</div>
        <div>PERFECT: ${hitCounts.PERFECT}</div>
        <div>GOOD: ${hitCounts.GOOD}</div>
        <div>MISS: ${hitCounts.MISS}</div>
    `;
    const retryBtn=document.createElement('button');
    retryBtn.innerText="Retry";
    retryBtn.onclick=()=>showStartScreen();
    ui.appendChild(div);
    ui.appendChild(retryBtn);
}

function drawBackground(){
    ctx.strokeStyle="white";
    ctx.beginPath();
    ctx.moveTo(laneWidth,0); ctx.lineTo(laneWidth,canvas.height); ctx.stroke();
    ctx.strokeStyle="red";
    ctx.beginPath();
    ctx.moveTo(0,hitLineY); ctx.lineTo(canvas.width,hitLineY); ctx.stroke();
    ctx.fillStyle="white"; ctx.font="25px sans-serif"; ctx.textAlign="center";
    ctx.fillText("F", laneWidth/2, canvas.height-20);
    ctx.fillText("J", laneWidth + laneWidth/2, canvas.height-20);
}

function showHitText(text){
    currentHitText=null;
    requestAnimationFrame(()=>{
        currentHitText={text:text, startTime:performance.now()};
        if(hitCounts[text]!==undefined) hitCounts[text]++;
    });
}

function judge(lane){
    if(!notes.length || !startTime || gameState!=="playing") return;
    const now = audioCtx.currentTime - startTime;
    for(let note of notes){
        if(!note.hit && note.lane===lane){
            const diff = now - note.startTime;
            if(Math.abs(diff) <= hitRangePerfectSec){ note.hit=true; score+=100; combo++; showHitText("PERFECT"); return;}
            else if(Math.abs(diff) <= hitRangeGoodSec){ note.hit=true; score+=50; combo++; showHitText("GOOD"); return;}
        }
    }
    combo=0; showHitText("MISS");
}

document.addEventListener("keydown",e=>{if(e.key=="f"||e.key=="F") judge(0); if(e.key=="j"||e.key=="J") judge(1);});
canvas.addEventListener("touchstart",e=>{
    e.preventDefault();
    for(let t of e.touches){
        const x = t.clientX - canvas.getBoundingClientRect().left;
        if(x < laneWidth) judge(0);
        else judge(1);
    }
},{passive:false});

function update(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();

    if(gameState==="playing"){
        const now = audioCtx.currentTime - startTime;
        const startY = -30;
        const fallDistance = hitLineY + 15;
        const fallTime = fallDistance / speedFactor; // 秒単位
        for(let note of notes){
            if(!note.hit){
                const appearTime = note.startTime - fallTime;
                if(now >= appearTime){
                    const y = startY + (now - appearTime) * speedFactor;
                    ctx.fillStyle="cyan";
                    ctx.beginPath();
                    ctx.arc(note.lane*laneWidth + laneWidth/2, y, 15, 0, Math.PI*2); ctx.fill();
                    if(y > hitLineY + 0.5*speedFactor/60){ note.hit=true; showHitText("MISS"); combo=0; }
                }
            }
        }
    }

    if(gameState==="countdown" && currentCountdown!=null){
        ctx.fillStyle="white"; ctx.font="60px sans-serif"; ctx.textAlign="center";
        ctx.fillText(currentCountdown, canvas.width/2, canvas.height/2);
    }

    if(currentHitText){
        const elapsed = performance.now() - currentHitText.startTime;
        if(elapsed < hitDisplayTime){
            ctx.fillStyle = currentHitText.text==="PERFECT"?"gold":currentHitText.text==="GOOD"?"lime":"red";
            ctx.font="40px sans-serif"; ctx.textAlign="center";
            ctx.fillText(currentHitText.text, canvas.width/2, canvas.height/2);
        } else currentHitText=null;
    }

    if(gameState==="playing"){
        ctx.fillStyle="white"; ctx.font="20px sans-serif"; ctx.textAlign="left";
        ctx.fillText(`Score: ${score} | Combo: ${combo}`, 10, 30);
    }

    requestAnimationFrame(update);
}

update();
</script>
</body>
</html>
